// Copyright (—Å) 2013 Gushcha Anton <ncrashed@gmail.com>
/*
* This file is part of Borey Engine.
*
* Boost Software License - Version 1.0 - August 17th, 2003
* 
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
* 
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/
// This file is written in D programming language
module stdlog;

import log;
import std.stream;
import std.path;
import std.stdio;
import std.file;
import std.conv;
import std.datetime;
import std.traits;

/**
*   Standart implementation of ILogger interface.
*/
synchronized class CLogger : ILogger
{
    enum DEFAULT_DIR = "./logs";
    enum DEFAULT_EXT = ".log";

    nothrow
    {   
        /**
        *   Log file name.
        */
        string name() const @property @safe
        {
            return mName;
        }

        /**
        *   Full log name.
        */
        string location() const @property @safe
        {
            return mLocation;
        }

        /**
        *   Prints message into log. Displaying in the console
        *   controlled by minOutputLevel property.
        */
        void log(lazy string message, LoggingLevel level) const @trusted
        {
            scope(failure) {}

            if(level >= mMinOutputLevel)
                writeln(logsStyles[level]~message);

            try
            {
                auto timeString = Clock.currTime.toISOExtString();
                mLogFile.writeLine(text("[", timeString, "]:", logsStyles[level], message));
            }
            catch(Exception e)
            {
                if(minOutputLevel != LoggingLevel.Muted)
                    writeln(logsStyles[LoggingLevel.Warning], "Failed to write into log ", mLocation);
            }
        }

        /**
        *   Returns: minimum log level,  will be printed in the console.
        */
        LoggingLevel minOutputLevel() const @property @trusted
        {
            return mMinOutputLevel;
        }

        /**
        *   Setups minimum log level, 
        */
        void minOutputLevel(LoggingLevel level) @property @trusted
        {
            mMinOutputLevel = level;
        }
    }

    this(string name, string dir = DEFAULT_DIR) @trusted
    {
        mName = name;
        mLocation = buildNormalizedPath(dir, name~DEFAULT_EXT);
        mMinOutputLevel = LoggingLevel.Notice;

        try
        {
            mLogFile = new std.stream.File(mLocation, FileMode.Out);
        } 
        catch(OpenException e)
        {
            throw new Exception(text("Failed to create log with name ", mName, " and location ", mLocation, ". Details: ", e.msg));
        }
    }
    
    /**
    *   Used to manual shutdown protocols.
    */
    void finalize() @trusted
    {
        scope(failure) {}
        close();
    }
    
    ~this()
    {
        finalize();
    }

    private
    {
        immutable(string) mName;
        immutable(string) mLocation;
        __gshared std.stream.File mLogFile;
        shared LoggingLevel mMinOutputLevel;

        void close()
        {
            mLogFile.close();
        }
    }
}

/// Display styles
private immutable(string[LoggingLevel]) logsStyles;

static this() 
{
    if(!exists(CLogger.DEFAULT_DIR))
    {
        mkdirRecurse(CLogger.DEFAULT_DIR);
    }

    logsStyles = [
        LoggingLevel.Notice  :   "Notice: ",
        LoggingLevel.Warning :   "Warning: ",
        LoggingLevel.Debug   :   "Debug: ",
        LoggingLevel.Fatal   :   "Error: ",
        LoggingLevel.Muted   :   "",
    ];
}

version(unittest)
{
    import std.concurrency;
    
    void testThread(shared ILogger logger, Tid owner, int i, uint n)
    {
        foreach(j; 1 .. n)
        {
            logger.logInfo(to!string(j));
            logger.logError(to!string(j));
        }
        
        send(owner, true);
    }
}
unittest
{
    import std.regex;
    import std.path;
    import std.file;
    import std.stdio;

    write("Testing log system... ");
    scope(success) writeln("Finished!");
    scope(failure) writeln("Failed!");

    auto logger = new shared CLogger("TestLog");
    logger.minOutputLevel = LoggingLevel.Muted;
    logger.log("Notice msg!", LoggingLevel.Notice);
    logger.log("Warning msg!", LoggingLevel.Warning);
    logger.log("Debug msg!", LoggingLevel.Debug);
    logger.log("Fatal msg!", LoggingLevel.Fatal);
    logger.close();

    auto f = new std.stdio.File(logger.location, "r");
    // Delete date string before cheking string
    assert(replace(f.readln()[0..$-1], regex(r"[\[][\p{InBasicLatin}]*[\]][:]"), "") == logsStyles[LoggingLevel.Notice]~"Notice msg!", "Log notice testing fail!");
    assert(replace(f.readln()[0..$-1], regex(r"[\[][\p{InBasicLatin}]*[\]][:]"), "") == logsStyles[LoggingLevel.Warning]~"Warning msg!", "Log warning testing fail!");
    assert(replace(f.readln()[0..$-1], regex(r"[\[][\p{InBasicLatin}]*[\]][:]"), "") == logsStyles[LoggingLevel.Debug]~"Debug msg!", "Log debug testing fail!");
    assert(replace(f.readln()[0..$-1], regex(r"[\[][\p{InBasicLatin}]*[\]][:]"), "") == logsStyles[LoggingLevel.Fatal]~"Fatal msg!", "Log fatal testing fail!");
    f.close();

    immutable n = 10;
    foreach(i; 1 .. n)
    {
        spawn(&testThread, logger, thisTid, i, n);
    }
    
    auto t = TickDuration.currSystemTick + cast(TickDuration)dur!"seconds"(2);
    auto ni = 0;
    while(ni < n && t > TickDuration.currSystemTick) 
    {
        ni += 1;
    }
    assert(ni == n, "Concurrent logging test is failed!");
    
    remove(logger.location);
}